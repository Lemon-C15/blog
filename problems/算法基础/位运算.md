# 位运算

* 基本运算
  1. '~' 取反，对于二进制每一位取反
  2. '&' 按位与，0 & 0 = 0 ，0 & 1 = 0 ，1 & 0 = 0 ，1 & 1 =1
      即同为1时结果才为1,否则结果为0  
  3. '|' 按位或，0  | 0 = 0 ，0 | 1 = 1 ，1 | 0 = 1 ，1 | 1 = 1
      即只要有1出现结果就是1，否则为0
  4. '^' 按位异或， 0 ^ 0 = 0 ，0 ^ 1 = 1 ，1 ^ 0 = 1 ，1 ^ 1 = 0
      即不同为1，相同为0
  
* lowbit( int n) 返回n二进制中最后一个1所表示的十进制数，其余为0，0010=2
  * 若n取反再+1，则此数就是和n互余(&)只包含最后一个1所表示的数。10=1010，~10=0101，+1=0110，n&(-n)->0010=2，10-2=8=1000；
  
  * 负数表示取反+1。~x+1=-x
  
  * ```c++
    int lowbit(){
        return x&-x;
    }
    ```
1. 例题：统计n中有几个1
  * 思路：不断将n中的1减去，看减几次0
```c++
#include <bits/stdc++.h>
using namespace std;
int lowbit(int x){
    return x&-x;//负数表示取反+1。~x+1=-x
}
int main(){
    int T;
    cin>>T;
    while(T--){
        int n;
        int res=0;
        cin>>n;
        while(n) n-=lowbit(n),res++;
        cout<<res<<' ';
    }
    return 0;
}
```
2. 例子: n的第k位是几,已知有4位(二进制)
  * 思路：'>>' 为二进制向右移动
```c++
    #include <bits/stdc++.h>
    using namespace std;
    int main(){
        int n=10;//
        //n>>k:把第k位移动到最后一位，右移动
        for(int k=3;k>=0;k--) cout<<(n>>k&1);//&:对应位同位1则为1
        return 0;//第1位移动n-1=3位
    }
```