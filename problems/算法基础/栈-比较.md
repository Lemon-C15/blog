/*
找到第一个大于自己的，否则为-1；
Sample Input
2
4 12 20 15 18
5 20 15 25 30 6

Sample Output
12–>20
20–>-1
15–>18
18–>-1

20–>25
15–>25
25–>30
30–>-1
6–>-1

Hint
本题数据量大、限时要求高，须借助栈来完成。
*/
原文链接：https://blog.csdn.net/qq_43545471/article/details/102509031
```c++
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
//三个数组，一个储存原数据，一个储存较大数，栈用来储存一个递增序列
typedef struct
{
    int data[100000];
    int top;
} seqstack;

void init_stack(seqstack *st)//初始化
{
    st->top = -1;
}

void push(seqstack *st, int num)//入栈
{
    st->top++;//栈的序号++
    st->data[st->top] = num;//数组存储较大数
}

void pop(seqstack *st)//模拟栈的弹出
{
    //int a = st->data[st->top];//取数
    st->top--;//自减
    //return a;
}

int get_top(seqstack *st)//取数
{
    return st->data[st->top];
}


int main()
{
    seqstack st;
    int i;
    int t, n;
    scanf("%d", &t);
    while(t--)
    {
        int a[100000]; // 储存原数据
        int b[100000]; // 储存当前值的较大值
        init_stack(&st); // 初始化栈top=-1
        scanf("%d", &n);
        for (i = 0; i < n; i++)
        {
            scanf("%d", &a[i]);
        }
        i = n-1;//Be the last one
        b[i] = -1; // 最后一个数的较大数一定为-1//无后数了
        for (i = n-2; i >= 0; i--) // 倒序遍历
        {
            int flag = 0;
            if (a[i+1] > a[i]) // 若后面的数大于当前数，则较大数为后面的数，并将较大数入栈
            {
                b[i] = a[i+1];
                push(&st, a[i+1]);//入相对较大的数->10 9 100 1
            }
            else // 否则到栈中找相对较大数//里面的数可能更大
            {
                while (st.top != -1)//最低数
                {
                    if (a[i] < get_top(&st))
                    {
                        b[i] = get_top(&st);
                        flag = 1;
                        break;
                    }
                    pop(&st); // 弹出前面的数
                }
                if (flag == 0) // 若没找到，则当前数没有较大数
                {
                    b[i] = -1;
                }
            }
        }
        for (i = 0; i < n; i++)
        {
            printf("%d-->%d\n", a[i], b[i]);
        }
        if (t != 0)
        {
            printf("\n");
        }
    }
    return 0;
}
```
