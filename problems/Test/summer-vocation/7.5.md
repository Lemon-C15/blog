# 7.5训练赛
## H.steaks
* https://codeforces.com/gym/102263/problem/H
* 切牛排，一个锅可以放两个，有n个牛排，煎一面5分钟，问最少几分钟
* n=3，k=1；a1+b1..a2+c1..b2+c2,最少15分钟
* 思路：肉分两面，锅分两瓣，一个锅链接两块不同的肉，此时一次最高效率，不能刚好加一次，总能链接到不同的肉
* 1.
```c++
#include <bits/stdc++.h>
using namespace std;
int main(){
    long long int n,k;
    cin>>n>>k;
    if(2*k>=n){
        cout<<10;
        return 0;
    }
    int N=n%k;
    if(N) N=5;
    else N=0;
    n=n/k;
    long long int time;
    time=n*5;
    cout<<time+N;
    return 0;
}
```
* 2.
```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int main()
{
    ll n,m;
    cin>>n>>m;
    if(n<=2*m) printf("10\n");
    else{
        ll ans=(2*n)/(2*m);
        if ((2 * n) % (2 * m)) ans++;
        ans*=5;
        cout<<ans<<endl;
    }
    return 0;
} 

```
## B.博弈 road to arabella
* https://vjudge.net/problem/Gym-102263B
* 先给个T，有T回合，给n和k，每次取x={1<=x<=max(1,m-k)},m为此时的n，然后使n=n-x，谁先让n等于0，让对方没得动就赢，a先手
* 思路：给对方偶数必赢，当m<=k或m-k=1，则只能减1，若此时a是偶数，减下去a必赢，若此时m>k,中间仍然可以只减一次一个特殊数使给到b的数为偶且以后只能减1，类似test2.
* test1：2 1；此时只能减1，b先减到0，b赢
* test2: 4 1；此时可以减1到3，减2，给b偶数2使b只能减1，a赢
* a先，若此时可以不只减1，则a必赢，若只能减1，a是奇数a必赢，否则b赢
```c++
#include <bits/stdc++.h>
using namespace std;
int main()
{
	int n;
	scanf("%d",&n);
	while(n--)
	{
		int a,b;
		cin>>a>>b;
		if(a==b||a-1==b)// 0 or 1
		{
			if(a&1)printf("Kilani\n");//奇偶，a为奇数返回1
			else printf("Ayoub\n");
		}
		else printf("Kilani\n");
	}
 
	return 0;
}

```