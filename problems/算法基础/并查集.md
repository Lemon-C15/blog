# 并查集
## 经典问题
* 判断两个数是否在一个集合
* 合并两个集合
## 概念
* find函数是来找祖先的
* 建立一个数组来放下标对应的父亲
* 祖先的父亲等于本身
* 路径压缩:把在路径上的每个节点都直接连接到根上
* * 无：不断让x=f[x],直到两者相等，就是祖先
* * 有：直接当祖先的儿子，让父亲等于爷爷的地位，递归判断爷爷是不是祖先，直到最后大家都和祖先一个地位，除了我
## 例题
1. 
*   
* 题目概括，合并两个集合或判断两个数是否在一个集合
```c++
# include<iostream>
# include<cstring>
using namespace std;
const int N = 1e5+10;
int p[N];
int find(int x){
    if(x!=p[x]) p[x]=find(p[x]);//如果不是让父亲去问上面的是不是祖先
    return p[x];//最后递归返回的都只是祖先
}
int main(){
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++) p[i]=i;//初始化，从1开始！
    while(m--){
        char op[2];
        int a,b;
        scanf("%s%d%d",op,&a,&b);
        if(*op=='M'){//最后返回的是祖先，我也是祖先
            p[find(a)]=find(b);//找祖先顺便合并，让一个祖先等于另一个祖先的儿子
        }
        else{  
            if(find(a)==find(b)) cout<<"Yes"<<endl;//找
            else cout<<"No"<<endl;
        }
    }
    return 0;
}
```